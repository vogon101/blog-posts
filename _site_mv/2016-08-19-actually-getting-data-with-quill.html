<p><a href="http://getquill.io">Quill</a> is a pretty cool scala library for generating SQL quieries at compile time. It has beautiful syntax and I really enjoy using it BUT it is <em>really</em> difficult to get set up with. This is a simple tutorial that should get you to the point where you have returned data from a MYSQL database.
<!-- more --></p>

<p>To start with we need to download the library. I will use SBT to include the library with the following code:</p>
<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="s">"mysql"</span> <span class="o">%</span> <span class="s">"mysql-connector-java"</span> <span class="o">%</span> <span class="s">"5.1.38"</span><span class="o">,</span>
  <span class="s">"io.getquill"</span> <span class="o">%%</span> <span class="s">"quill-jdbc"</span> <span class="o">%</span> <span class="s">"0.8.0"</span>
<span class="o">)</span>
</code></pre>
</div>
<p>This will download the MYSQL driver needed as well ast the main quill library. Now for some code. All of this will be in the <code class="highlighter-rouge">src/main/scala</code> directory. The first file needed is <code class="highlighter-rouge">application.properties</code> which will contain the needed application settings:</p>
<pre><code class="language-YAML">ctx.dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
ctx.dataSource.url=jdbc:mysql://127.0.01/TestDB
ctx.dataSource.user=root
ctx.dataSource.password=passw0rd
ctx.dataSource.cachePrepStmts=true
ctx.dataSource.prepStmtCacheSize=250
ctx.dataSource.prepStmtCacheSqlLimit=2048
ctx.connectionTimeout=30000
</code></pre>
<p>This is all the configuration we need to connect to a MYSQL database hosted on localhost and the database TestDB. Quill allows easy object with case classes so we need to create these to hold the data. In this schema I will represent the current US presidential election with a table for candidates:</p>

<table>
  <thead>
    <tr>
      <th>| id (Int) |</th>
      <th style="text-align: right">name (String)</th>
      <th style="text-align: right">| election(Int)</th>
      <th style="text-align: right">| party(Int)</th>
      <th>|</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: right">Hillary Clinton</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">1</td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: right">Donald Trump</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">2</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>This is a very simple table and we will call it <code class="highlighter-rouge">Candidate</code>. A case class is all we need to represent this in scala. This will be what quill returns when it gets data from the database. I will put this in a package called DBObjects to store these case classes.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">package</span> <span class="nn">com.vogonjeltz.election.db.DBObjects</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Candidate</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">election</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">party</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{}</span>
</code></pre>
</div>

<p>Now we need to connect to the database by creating a <code class="highlighter-rouge">JdbcContext</code>. This requires us selecting our dialect and a naming strategy. The dialect is the type of sql we are usig which in this case is is the <code class="highlighter-rouge">MySQLDialect</code> and the naming strategy is how the names of the tables and fields are transformed. I will be using Literal which wont transform them at all. The easiest place to put this context is in a package object. I will put it in the db package. Here is <code class="highlighter-rouge">src/main/scala/com/vogonjeltz/package.scala</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">package</span> <span class="nn">com.vogonjeltz.election</span>

<span class="k">import</span> <span class="nn">io.getquill.</span><span class="o">{</span><span class="nc">JdbcContext</span><span class="o">,</span> <span class="nc">Literal</span><span class="o">,</span> <span class="nc">MySQLDialect</span><span class="o">}</span>

<span class="k">package</span> <span class="nn">object</span> <span class="n">db</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">JdbcDatabase</span> <span class="o">=</span> <span class="nc">JdbcContext</span><span class="o">[</span><span class="kt">MySQLDialect</span>, <span class="kt">Literal</span><span class="o">]</span>

  <span class="k">lazy</span> <span class="k">val</span> <span class="n">ctx</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JdbcDatabase</span><span class="o">(</span><span class="s">"ctx"</span><span class="o">)</span>

<span class="o">}</span>
</code></pre>
</div>

<p>Now to select data from the database. The methods we need are in that context instance so accessing them is east as importing <code class="highlighter-rouge">db.ctx._</code>. The <code class="highlighter-rouge">quote</code> method is what quill uses to create the SQL at compile time (or runtime if it can’t figure it out). Here is a test <code class="highlighter-rouge">App</code>:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">package</span> <span class="nn">com.vogonjeltz.election</span>

<span class="k">import</span> <span class="nn">com.vogonjeltz.election.db.DBObjects.Candidate</span>
<span class="k">import</span> <span class="nn">db._</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">ctx._</span>

  <span class="k">val</span> <span class="nc">HRCQuery</span> <span class="k">=</span> <span class="n">quote</span> <span class="o">{</span>
    <span class="n">query</span><span class="o">[</span><span class="kt">Candidate</span><span class="o">].</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>This will generate the SQL <code class="highlighter-rouge">SELECT * FROM Candidate WHERE id = 1</code> (or equivalent).  This is can then be executed by running it against the context:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="nc">HRC</span> <span class="k">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="nc">HRCQuery</span><span class="o">)</span>

<span class="n">println</span><span class="o">(</span><span class="nc">HRC</span><span class="o">)</span>
</code></pre>
</div>

<p>This will print out: <code class="highlighter-rouge">Candidate(1, "Hillary Clinton", 1, 1)</code> and there you go. You have successfully got data from a MYSQL (or whichever db you used).You can read about more complicated queries <a href="http://getquill.io">here</a>.</p>

<p>Thanks for reading,</p>

<p>Freddie</p>
